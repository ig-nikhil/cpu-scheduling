# CPU Scheduling Visualization Website

## Overview
This project is a web-based application designed to help users understand and analyze various CPU scheduling techniques. The website provides an interactive and visual representation of different scheduling algorithms, allowing users to compare their performance and understand how they work in a real-time environment.

## Features
- **Interactive Interface:** A user-friendly interface developed with HTML, CSS, and JavaScript for seamless interaction.
- **Visualization of Scheduling Algorithms:** Real-time graphical representation of different CPU scheduling algorithms, including:
  - First-Come, First-Served (FCFS)
  - Shortest Job first (SJF)
  - Priority Scheduling
  - Round Robin (RR)
- **Custom Input:** Users can input custom process data to see how different algorithms handle various workloads.
- **Performance Metrics:** Display of key metrics like average waiting time, turnaround time, and CPU utilization for each algorithm.
- **Responsive Design:** Compatible with different screen sizes for accessibility across devices.

## Technologies Used
- **HTML5:** For structuring the content of the website.
- **CSS3:** For styling and layout design to ensure an appealing user interface.
- **JavaScript:** To implement interactive features and logic for scheduling algorithms.

## How to Use
1. Input the number of processes and their respective details such as arrival time, burst time, priority, etc.
2. Select the CPU scheduling algorithm you want to visualize.
3. Click on the "Start Simulation" button to see the algorithm in action.
4. Observe the Gantt chart and performance metrics displayed for a better understanding of the algorithm's behavior.

## Future Enhancements
- Addition of more advanced CPU scheduling algorithms.
- Exporting the visualization results as images or PDFs.
- Including a tutorial section to explain the theory behind each algorithm.

## Contributing
Contributions are welcome! If you'd like to contribute, please fork the repository and use a feature branch. Pull requests are warmly welcomed.

